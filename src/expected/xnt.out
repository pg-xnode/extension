set search_path to xml;
CREATE TABLE templates (
	id integer NOT NULL,
	template xnt
);
INSERT INTO templates VALUES 
-- the simplest case: only attribute values are parametrized
(0, '<xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt"><point x="{$p1}" y="{$p2}"/></xnt:template>'),
-- in addition, parameter is used to generate the element name as well as attribute names
(1, '<xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt">
<xnt:element name="point_{$p1}">
	<xnt:attribute name="x_{$p1}" value="{$p2}"/>
	<xnt:attribute name="y_{$p2}" value="{$p3}"/>
</xnt:element>
</xnt:template>'),
-- node can also be used as parameter
(2, '<xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt">
<area><xnt:copy-of expr="$p1"/></area>
</xnt:template>');
SELECT id, template
FROM templates
ORDER BY id;
 id |                                             template                                              
----+---------------------------------------------------------------------------------------------------
  0 | <xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt"><point x="{$p1}" y="{$p2}"/></xnt:template>
  1 | <xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt">                                           +
    | <xnt:element name="point_{$p1}">                                                                 +
    |         <xnt:attribute name="x_{$p1}" value="{$p2}"/>                                            +
    |         <xnt:attribute name="y_{$p2}" value="{$p3}"/>                                            +
    | </xnt:element>                                                                                   +
    | </xnt:template>
  2 | <xnt:template xmlns:xnt="http://www.pg-xnode.org/xnt">                                           +
    | <area><xnt:copy-of expr="$p1"/></area>                                                           +
    | </xnt:template>
(3 rows)

CREATE TABLE points (
	id integer NOT NULL,
	x float NOT NULL,
	y float NOT NULL
);
INSERT INTO points VALUES
(0, 0.0, 0.0), (1, 0.3, 5.4), (2, 3.15, 0.01);
CREATE TABLE point_nodes (
	id integer NOT NULL,
	p node NOT NULL
);
INSERT INTO point_nodes
SELECT p.id, xml.node(t.template, '{p1, p2}', ROW (x, y))
FROM templates t, points p
WHERE t.id=0;
SELECT *
FROM point_nodes
ORDER BY id;
 id |             p              
----+----------------------------
  0 | <point x="0" y="0"/>
  1 | <point x="0.3" y="5.4"/>
  2 | <point x="3.15" y="0.01"/>
(3 rows)

SELECT xml.node(template, '{p1, p2, p3}', ROW (p.id, p.x, p.y))
FROM templates t, points p
WHERE t.id=1
ORDER BY p.id;
                node                 
-------------------------------------
 <point_0 x_0="0" y_0="0"/>
 <point_1 x_1="0.3" y_0.3="5.4"/>
 <point_2 x_2="3.15" y_3.15="0.01"/>
(3 rows)

-- use CTE to ensure that order of nodes within the fragment is always the same 
WITH point_nodes_ordered(p) AS (
	SELECT p
	FROM point_nodes
	ORDER BY id
), 
fragments(f) AS (
	SELECT xml.fragment(p)
	FROM point_nodes_ordered
)
SELECT xml.node(t.template, '{p1}', ROW(f))
FROM fragments f,
templates t
WHERE t.id=2;
                                        node                                         
-------------------------------------------------------------------------------------
 <area><point x="0" y="0"/><point x="0.3" y="5.4"/><point x="3.15" y="0.01"/></area>
(1 row)

DROP TABLE templates;
DROP TABLE points;
DROP TABLE point_nodes;
